<!--
 * @Description: 
 * @Autor: hanipig
 * @Date: 2021-03-29 21:04:26
 * @LastEditors: Please set LastEditors
 * @LastEditTime: 2021-03-30 00:35:02
-->
## 常见手写题

### 深拷贝函数

``` JavaScript 
  function deepClone(obj){
    if (typeof(obj) !== "object" || obj === null) return obj;

    let res = Object.prototype.toString.call(obj) === "[object Array]" ? [] : {};
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        res[key] = deepClone(obj[key]);
      }
    }
    return res;
  }
```

### instanceof 实现

``` JavaScript
  function myInstanceof (L, R) {
    let LProto = L.__proto__;
    let RPrototype = R.propertype;
    while (true) {
      if (LProto === null) return false;
      
      if (LProto === RPrototype) return true;

      LProto = LProto  > .__proto__;
    }
  }
```

### 防抖、节流

> 1. 防抖：在规定的时间内多次触发某一时间，会把之前的回调取消，以最后规定时间内一次的触发为准
  > + this指向window问题
  > + event指向undefined问题
  > + 怎么实现立即执行
  > + 返回值（只考虑immediate为true的情况）
  > + 取消

```JavaScript
  function debounce(fn, wait, immediate){
    let timer, res;

    if (timer) clearTimeout(timer);//如果指定时间内再次触发，取消之前的回调

    let debounced = function () {
      let args = arguments;//参数
      let context = this;//目标对象
      
      if (immediate) {
        let callNow = !timer;//如果之前未执行过，则!timer为true 即立即执行
        timer = setTimeout(function () {
          timer = null;//每次执行完回调把timer设置为null，确保每下一次能够立即执行
          console.log("可以再次触发了");
        }, wait);
        if (callNow) {
          res = fn.apply(context, args);
        }
      } else {
        timer = setTimeout(function () {
          fn.apply(context, args);
        }, wait)
      }
      return res;
    }

    //取消
    debounced.cancel = function () {
      clearTimeout(timer);
      timer = null;
    }

    return debounced;
  }
```

> 2. 节流：在规定的时间内只会触发执行一次时事件回调
> 
> + 时间戳实现（立即执行,有头无尾）
  ``` JavaScript
      function throttle1 (fn, wait) {
        let pre = 0;//上一次的时间戳

        return function () {
          let context = this;
          let args = arguments;
          let curr = +new Date();

          if ((curr - pre) >= wait) {
            fn.apply(context, args);
            pre = curr;
            console.log("可以再次触发了");
          }
        }
      }
  ```
    
> + 定时器实现（指定时间后执行，无头有尾）
  ``` JavaScript
      function throttle2 (fn, wait) {
        let timer = null;

        return function () {
          let context = this;
          let args = arguments;

          if (!timer) {
            timer = setTimeout(function () {
              timer = null;
              fn.apply(context, args);
            }, wait);
          }
        }
      }
  ```

> + 定时器、时间戳结合实现（有头有尾）
  ``` JavaScript
      //两者结合 有头有尾
      function throttle3 (fn, wait) {
        let timer,
          pre = 0;

        return function () {
          let args = arguments;
          let context = this;
          let curr = +new Date();
          let remaining = wait - (curr - pre);
          if (remaining <= 0 || remaining > wait) {//如果没有剩余的时间了或者改了系统时间
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }

            pre = curr;
            fn.apply(context, args);

          } else if (!timer) {
            timer = setTimeout(function () {
              pre = curr;
              timer = null;
              fn.apply(context, args);
            }, remaining);
          }
        }
      }
  ```


### new 实现

### class 实现

### call、bind、apply

### promise 实现

### 函数柯里化

### 数组扁平化

