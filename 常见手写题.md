<!--
 * @Description: 
 * @Autor: hanipig
 * @Date: 2021-03-29 21:04:26
 * @LastEditors: Please set LastEditors
 * @LastEditTime: 2021-03-29 23:10:44
-->
## 常见手写题

### 深拷贝函数

``` JavaScript 
  function deepClone(obj){
    if (typeof(obj) !== "object" || obj === null) return obj;

    let res = Object.prototype.toString.call(obj) === "[object Array]" ? [] : {};
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        res[key] = deepClone(obj[key]);
      }
    }
    return res;
  }
```

### instanceof 实现

``` JavaScript
  function myInstanceof (L, R) {
    let LProto = L.__proto__;
    let RPrototype = R.propertype;
    while (true) {
      if (LProto === null) return false;
      
      if (LProto === RPrototype) return true;

      LProto = LProto  > .__proto__;
    }
  }
```

### 防抖、节流

> 1. 防抖：在规定的时间内多次触发某一时间，会把之前的回调取消，以最后规定时间内一次的触发为准
  > + this指向window问题
  > + event指向undefined问题
  > + 怎么实现立即执行
  > + 返回值（只考虑immediate为true的情况）
  > + 取消

```JavaScript
  function debounce(fn, wait, immediate){
    let timer, res;

    if (timer) clearTimeout(timer);//如果指定时间内再次触发，取消之前的回调

    let debounced = function () {
      let args = arguments;//参数
      let context = this;//目标对象
      
      if (immediate) {
        let callNow = !timer;//如果之前未执行过，则!timer为true 即立即执行
        timer = setTimeout(function () {
          timer = null;//每次执行完回调把timer设置为null，确保每下一次能够立即执行
          console.log("可以再次触发了");
        }, wait);
        if (callNow) {
          res = fn.apply(context, args);
        }
      } else {
        timer = setTimeout(function () {
          fn.apply(context, args);
        }, wait)
      }
      return res;
    }

    //取消
    debounced.cancel = function () {
      clearTimeout(timer);
      timer = null;
    }

    return debounced;
  }
```

> 2. 节流：在规定的时间内只会触发执行一次时事件回调

``` JavaScript

```

### new 实现

### class 实现

### call、bind、apply

### promise 实现

### 函数柯里化

### 数组扁平化

