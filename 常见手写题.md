<!--
 * @Description: 
 * @Autor: hanipig
 * @Date: 2021-03-29 21:04:26
 * @LastEditors: Please set LastEditors
 * @LastEditTime: 2021-03-30 23:47:31
-->
## 常见手写题

### 深拷贝函数

``` JavaScript 
  function deepClone(obj){
    if (typeof(obj) !== "object" || obj === null) return obj;

    let res = Object.prototype.toString.call(obj) === "[object Array]" ? [] : {};
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        res[key] = deepClone(obj[key]);
      }
    }
    return res;
  }
```

### instanceof 实现

``` JavaScript
  function myInstanceof (L, R) {
    let LProto = L.__proto__;
    let RPrototype = R.propertype;
    while (true) {
      if (LProto === null) return false;
      
      if (LProto === RPrototype) return true;

      LProto = LProto  > .__proto__;
    }
  }
```

### 防抖、节流

> 1. 防抖：在规定的时间内多次触发某一时间，会把之前的回调取消，以最后规定时间内一次的触发为准
  > + this指向window问题
  > + event指向undefined问题
  > + 怎么实现立即执行
  > + 返回值（只考虑immediate为true的情况）
  > + 取消

```JavaScript
  function debounce(fn, wait, immediate){
    let timer, res;

    if (timer) clearTimeout(timer);//如果指定时间内再次触发，取消之前的回调

    let debounced = function () {
      let args = arguments;//参数
      let context = this;//目标对象
      
      if (immediate) {
        let callNow = !timer;//如果之前未执行过，则!timer为true 即立即执行
        timer = setTimeout(function () {
          timer = null;//每次执行完回调把timer设置为null，确保每下一次能够立即执行
          console.log("可以再次触发了");
        }, wait);
        if (callNow) {
          res = fn.apply(context, args);
        }
      } else {
        timer = setTimeout(function () {
          fn.apply(context, args);
        }, wait)
      }
      return res;
    }

    //取消
    debounced.cancel = function () {
      clearTimeout(timer);
      timer = null;
    }

    return debounced;
  }
```

> 2. 节流：在规定的时间内只会触发执行一次时事件回调
> 
> + 时间戳实现（立即执行,有头无尾）
  ``` JavaScript
      function throttle1 (fn, wait) {
        let pre = 0;//上一次的时间戳

        return function () {
          let context = this;
          let args = arguments;
          let curr = +new Date();

          if ((curr - pre) >= wait) {
            fn.apply(context, args);
            pre = curr;
            console.log("可以再次触发了");
          }
        }
      }
  ```
    
> + 定时器实现（指定时间后执行，无头有尾）
  ``` JavaScript
      function throttle2 (fn, wait) {
        let timer = null;

        return function () {
          let context = this;
          let args = arguments;

          if (!timer) {
            timer = setTimeout(function () {
              timer = null;
              fn.apply(context, args);
            }, wait);
          }
        }
      }
  ```

> + 定时器、时间戳结合实现（有头有尾）
  ``` JavaScript
      //两者结合 有头有尾
      function throttle3 (fn, wait) {
        let timer,
          pre = 0;

        return function () {
          let args = arguments;
          let context = this;
          let curr = +new Date();
          let remaining = wait - (curr - pre);
          if (remaining <= 0 || remaining > wait) {//如果没有剩余的时间了或者改了系统时间
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }

            pre = curr;
            fn.apply(context, args);

          } else if (!timer) {
            timer = setTimeout(function () {
              pre = curr;
              timer = null;
              fn.apply(context, args);
            }, remaining);
          }
        }
      }
  ```

> + 定时器、时间戳结合实现（通过options参数决定无头有尾、有头无尾）

  ``` JavaScript
      //leading：false 表示禁用第一次执行
      //trailing: false 表示禁用停止触发的回调
      //两者不能同时为false
      function throttle4 (fn, wait, options) {
        let timer,
          pre = 0;
        if (!options) options = {};
        
        let throttled =  function () {
          let args = arguments;
          let context = this;
          let curr = +new Date();
          if (!pre && options.leading === false) pre = curr

          let remaining = wait - (curr - pre);
          
          if (remaining <= 0 || remaining > wait) {//如果没有剩余的时间了或者改了系统时间
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }

            pre = curr;
            fn.apply(context, args);

            if(!timer) context = args = null;
          } else if (!timer && options.trailing !== false) {
            timer = setTimeout(function () {
              pre = options.leading === false ? 0 : new Date().getTime();
              timer = null;
              fn.apply(context, args);
              if(!timer) context = args = null;
            }, remaining);
          }
        }

        throttled.cancel = function () {
          clearTimeout(timer);
          pre = 0;
          timer = null;
        }

        return throttled;
      }
  ```


### new 实现
+ 创建一个对象
+ 访问构造函数中的属性
+ 访问原型对象中的属性
+ 返回值为基本类型时忽略（即返回创建的这个对象）；返回引用类型时直接忽略创建的这个对象
  
  ``` JavaScript
    //fn为构造函数
    function myNew (fn) {
      let obj = new Object;
      let Constructor = [].shift.call(arguments);//获取构造函数 即fn
      let prototype = Constructor.prototype;//构造函数的原型对象
      
      //需要考虑构造函数有返回值得情况
      let res = fn.apply(obj, arguments);//调用构造函数，此时arguments已去除构造函数（shift直接修改原数组，返回移除的元素）

      //如果返回值是基本类型的则返回obj，否则返回res（此处暂只判断了object，并不全面）
      return typeof res === "object" ? res : obj;
    }
  ```

### call、bind、apply
  + call：在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法
  
  ``` JavaScript
    //1.把fn置为obj的方法
    //2.调用obj.fn
    //3.删除obj.fn
    //注意点：obj 有可能为null，此时this指向window；call可能有返回值
    
    Function.prototype.myCall = function(context) {
      var context = context || window;
      //this为指向调用call的函数
      context.fn = this;
      //call可传参，通过arguments可获取
      var args = [];
      for (var i = 1; i < arguments.length; i++)
      {
        args.push('arguments[' + i + ']');
      } 
      var res = eval('context.fn(' + args + ')');

      delete context.fn;
      
      return res;
    }
  ```
  
  + apply
  
  ``` JavaScript
    //与call实现类似
    Function.prototype.myApply = function(context, arr) {
      var context = context || window;
      context.fn = this;

      var res;
      if (!arr) {
        res = obj.fn();
      } else {
        var args = [];
        for (var i = 1; i < arr.length; i++)
        {
          args.push('arr[' + i + ']');
        } 
        var res = eval('context.fn(' + args + ')');
      }

      delete context.fn;
      
      return res;
    }
  ```

  + bind
  
  ``` JavaScript
  
  ```

### class 实现

### promise 实现

### 函数柯里化

### 数组扁平化

