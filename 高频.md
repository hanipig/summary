<!--
 * @Description:
 * @Autor: hanipig
 * @Date: 2021-04-06 23:54:26
 * @LastEditors: Please set LastEditors
 * @LastEditTime: 2021-04-11 23:15:26
-->

## 高频

### JavaScript

- 讲讲 js 数据类型？基本和引用的区别？symbol 和 bigint 讲一讲应用场景？

  > 1. 分基本数据类型、引用类型
  > 2. 基本：string，number，boolean，undefined，null，symbol，bigint；引用：object
  > 3. 基本数据类型按值访问，保存在栈中，存储大小固定；引用类型按引用访问，存储在内存中，大小不定
  > 4. Symbol 指的是独一无二的值。每个通过 Symbol() 生成的值都是唯一的，通常用来生成对象属性名，为避免重复；BigInt 数据类型提供了一种方法来表示大于 2^53 的整数。BigInt 可以表示任意大的整数。解决超出 2^53 数字范围精度丢失问题

- 判断数据类型的方法？instanceof 原理?判断空对象？ typof null？typeof NaN？

  > 1. typeof、instanceof、isArray、Object.prototype.toString()
  > 2. typeof 可能的值：string、number、boolean、undefined、sysbol、bigint、function、object；typeof 能检测出除 null 的其他基本类型，不能明确区分是哪种引用类型，可通过 instancof 检测是否是某种引用类型或者 使用 Object.prototype.toString
  > 3. 判断对象是否为空：（1）JSON.stringify(obj) === "{}"（2）for in 判断（3）ES6 Object.keys()（4）Object.getOwnPropertyNames()方法

- var/let/const 区别？暂时性死区？块级作用域？const a = {}; a.x = 1 能不能修改？

  > var 声明提升，可重复声明；let、const 添加了块级作用域，约束了声明提升，在声明之前不能使用，不然会报错（暂时性死区），不能重复声明；const 声明的时候就要赋值，而且不能重新赋值（但是引用类型可修改属性）

- 说说你对函数式编程的理解？函数柯里化的理解？平时的使用场景？

  > 1. 简单说，"函数式编程"是一种"编程范式"（programming paradigm），也就是如何编写程序的方法论.它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是"第一等公民"、只用"表达式"
  > 2. 在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用。

- 防抖、节流的含义，使用场景？手写一下？

  > 1. 所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
  > 2. 所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。

- call、apply、bind 区别？bind 实现？bind 之后还能修改 this 指向吗？为什么？

  > 1. 相同点：三者都可修改函数运行时的 this 指向
  > 2. 不同点：bind 返回修改 this 后的函数，并不会立即执行函数；apply、call 修改完 this 立即执行；apply 于 call 区别在于传参不同，前者传入数组，后者逐个参数传入
  > 3. bind 之后不能修改 this 的指向

- 闭包概念，最主要的还是问闭包的场景？

- 用 es5 实现 es6 类的继承？各种继承

- 深拷贝与浅拷贝？常用方法？手写一个深拷贝函数？
- 说说你知道的 JavaScript 设计模式？观察者和发布订阅的区别？手写一个发布订阅？
- 说说对你对 JavaScript 异步编程的理解？
- ES Module 与 CommonJS 模块的差异？两者互相加载的方式？一般会扯到 AMD
- Promise.all、race、allSettled 概念、手写？很多手写题都会用到，比如用 promise 实现请求并发个数限制？
- 对象创建？

  - 1. 对象字面量模式：
  - 2. 工厂模式

    ```JavaScript
      function createPerson (name, age) {
        let o = new Object();
        o.name = name;
        o.age = age;
        o.sayName = function () {
          console.log(this.name);
        }
        return o;
      }
      let person1 = createPerson("sup h", 24);
    ```

  > 可解决多个类似对象的问题，但没有解决对象标识问题（instanceof）；

  - 3.  构造函数模式

    ```JavaScript
      function Person(name, age) {
        this.name = name;
        this.age = age;
        this.sayName = function () {
          console.log(this.name);
        }
      }
      let person1 = new Person("sup h", 24);
    ```

  > 可确保实例被标识为特定类型，但其定义的方法会在每个实例上都创建一遍；即使把函数定义转移到构造函数外部可解决重复创建的问题，但是会污染全局函数。

  - 4. 原型模式

  ```JavaScript
    function Person () {}

    Person.name = "sup h";
    Person.age = 24;
    Person.sayName = function () {
      console.log(this.name);
    }

    let person1 = new Person();
  ```

  > 好处是，在它上面定义的属性和方法可被对象实例共享；缺点是，（1）弱化了构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值（2）共享特性（针对引用类型）

- 对象及继承？

## Http && 浏览器

- 浏览器缓存？http 缓存？ 主要要讲一讲强缓存、协商缓存、preload、prefetch、Service Worker 等，304 的含义？协商缓存 e-tag 是怎么生成的？Last-Modified 是基于什么生成的？两者对比一下？优先级哪个高？
- 什么是跨域？什么情况下会跨域？浏览器根据什么字段判断是否允许跨域？跨域的解决方案有哪些？options 请求了解过吗？说说 CORS 中的简单请求和复杂请求？form 表单提交会跨域吗？
- 讲一讲浏览器事件循环 Event Loop？node 事件循环描述一下？
- http2 有哪些新特性？http2 还有哪些缺陷？http3 的一些了解？
- 从输入 URL 到页面加载完成的过程，一般要很详细的描述：包括 DNS 查询，缓存查询，3 次握手，4 次挥手，浏览器渲染进程等，面试官会从里面再挑几个问题深入问，比如为什么是 3 次握手 4 次挥手？渲染进程中的 GUI 渲染线程、JS 引擎线程、事件触发线程等等？可能会问到进程线程的区别？浏览器为什么是多进程？js 为什么是单线程？怎么支持多线程？等等
- https 加密原理？主要是讲对称加密和非对此加密结合使用的一个过程。什么是中间人攻击？和 http 区别？

## Vue

- 生命周期？那个生命周期可以获取到真实 DOM？修改 data 里面的数据，会触发什么生命周期？
- 组件 data 为什么是一个函数？
- vue 组件通信？一般说了 vuex，就会问 vuex 用法？action 和 mutations 区别？实现原理等？
- vue 导航守卫，分全局和组件的，一般用于权限控制，这个就可能扯到项目中的一些鉴权问题。
- \$nextTick 作用？实现原理？微任务向宏任务的降级处理，经常被问到说出几种宏任务，微任务。
- vue 响应式原理？基本都会问
- vue scoped 属性作用？实现原理？
- vue router 有几种模式？实现方式？
- key 的作用？没有 key 的情况，vue 会怎么做？会引出 diff 的问题
- vue diff 过程，和 react diff 区别？
- vue 2.x defineProperty 缺陷？业务代码里面怎么处理？\$set 原理？vue 是怎么重写数组方法的？考察你是不是真的看过源码
- vue 3.0 proxy 优缺点？怎么处理 vue3 不支持 IE？
- computed 和 watch 的区别和运用的场景？除了基本的，看你能不能说出三种 watcher 的区别

## Webpack

- webpack 构建流程？打包原理？

  > Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：

  - 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数
  - 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译
  - 确定入口：根据配置中的 entry 找出所有的入口文件
  - 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
  - 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
  - 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
  - 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

  > 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。简单说

  - 初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler
  - 编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理
  - 输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中

- 项目中做的一些优化？

- loader 和 plugin 的区别？有没有写过？常用哪些 loader 和 plugin
- webpack 热跟新原理？
- tree-shaking？对于 CommonJS，tree shaking 怎么办？
- webpack loader 的执行顺序？从左到右？从上到下？
